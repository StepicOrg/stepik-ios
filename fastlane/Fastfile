# This is the minimum version number required.
fastlane_version "2.93.1"

default_platform :ios

platform :ios do
    # Config variables

    team_id = ENV["FASTLANE_TEAM_ID"]
    keychain_password = ENV["KEYCHAIN_PASSWORD"]

    # Constants

    project_metapath = "./fastlane/metadata"
    project_screenpath = "./fastlane/screenshots"

    schemes = {
        "Stepic" => [
            "Stepic",
            "StepicWatch", 
            "StepicWatch Extension", 
            "StickerPackExtension"
        ],
        "Adaptive 1838" => [
            "Adaptive 1838"
        ],
        "Adaptive 3150" => [
            "Adaptive 3150"
        ],
        "Adaptive 3149" => [
            "Adaptive 3149"
        ],
        "Adaptive 3124" => [
            "Adaptive 3124"
        ],
        "Adaptive GMAT" => [
            "Adaptive GMAT"
        ],
        "Adaptive 8290" => [
            "Adaptive 8290"
        ]
    }

    # Helpers

    def version_string(version_number, build_number)
        "v. #{version_number} (#{build_number})"
    end

    def get_bundle_id(options)
        project_path = options[:xcodeproj] ? File.join(options[:xcodeproj], '..') : Dir.glob("../*.xcodeproj").first
        scheme = options[:scheme]

        if project_path
            project = Xcodeproj::Project.open(project_path)
        else 
            UI.user_error!("Unable to find xcodeproj file")
        end

        scheme = project.native_targets.find { |target| target.name == scheme }
        build_configuration = scheme.build_configurations.first

        if build_configuration.nil?
            UI.user_error!("Unable to find build configuration")
        end

        build_configuration.build_settings['PRODUCT_BUNDLE_IDENTIFIER']
    end

    def build_bundle_id_to_scheme_mapping(schemes, scheme, provisioning_profile_mapping)
        bundle_id_to_scheme = {}
        dependent_schemes = schemes[scheme]
        for i in dependent_schemes
            bundle_id_to_scheme[get_bundle_id(scheme: i)] = i
        end

        bundle_id_to_scheme
    end

    # Private lanes

    private_lane :match_scheme do |options|
        scheme = options[:scheme]
        type = options[:type]
        dependent_schemes = schemes[scheme]
        identifiers = dependent_schemes.map { |scheme| get_bundle_id(scheme: scheme) }

        match(
            type: type,
            force_for_new_devices: true,
            readonly: true,
            app_identifier: identifiers
        )
    end

    private_lane :set_manual_code_signing do |options|
        if team_id.nil? || team_id.empty?
            UI.user_error!("Team ID can not be empty!")
        end

        scheme = options[:scheme]
        provisioning_profile_mapping = options[:provisioning_profile_mapping]
        bundle_id_to_scheme = build_bundle_id_to_scheme_mapping(
            schemes, 
            scheme, 
            provisioning_profile_mapping
        )

        provisioning_profile_mapping.each do |key, value|
            automatic_code_signing(
                use_automatic_signing: false,
                targets: [bundle_id_to_scheme[key]],
                profile_name: value,
                team_id: team_id,
                code_sign_identity: "iPhone Distribution"
            )
        end
    end

    private_lane :set_auto_code_signing do |options|
        if team_id.nil? || team_id.empty?
            UI.user_error!("Team ID can not be empty!")
        end

        scheme = options[:scheme]
        provisioning_profile_mapping = options[:provisioning_profile_mapping]
        bundle_id_to_scheme = build_bundle_id_to_scheme_mapping(
            schemes, 
            scheme, 
            provisioning_profile_mapping
        )

        provisioning_profile_mapping.each do |key, value|
            automatic_code_signing(
                use_automatic_signing: true,
                targets: [bundle_id_to_scheme[key]],
                profile_name: "",
                team_id: team_id,
                code_sign_identity: "iPhone Developer"
            )
        end
    end

    # Lanes

    desc "Run all tests for scheme."
    desc "Options: scheme"
    lane :test do |options|
        clear_derived_data

        ENV["FASTLANE_EXPLICIT_OPEN_SIMULATOR"] = "0"
        scheme = options[:scheme]

        cocoapods(try_repo_update_on_error: true)

        scan(
            scheme: scheme,
            slack_only_on_failure: true
        )
    end

    desc "Submit a new Beta Build to Crashlytics."
    desc "This will also make sure the profile is up to date."
    desc "Options: scheme"
    lane :beta do |options|
        scheme = options[:scheme]

        clear_derived_data
        cocoapods(repo_update: true)

        unlock_keychain

        match_adhoc(scheme: scheme)

        # Disable automatic code signing -> build -> enable again
        set_manual_code_signing(
            provisioning_profile_mapping: lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING],
            scheme: scheme
        )
        begin
            gym(
                scheme: scheme,
                clean: true,
                output_directory: "artefacts",
                output_name: "#{scheme}.ipa",
                include_bitcode: true,
                skip_profile_detection: true,
                export_method: "ad-hoc",
                export_options: {
                    # use only provisioning profiles from match
                    provisioningProfiles: lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]
                }
            )
        ensure
            set_auto_code_signing(
                provisioning_profile_mapping: lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING],
                scheme: scheme
            )
            clean_build_artifacts
        end

        crashlytics(
            notifications: true,
            groups: "all-ios-testers"
        )

        slack(
            message: "Successfully released iOS beta #{scheme} #{version_string(get_version_number, get_build_number)}",
            channel: "#ios-ci"
        )
    end

    desc "Match all certificates for scheme."
    desc "Options: scheme"
    lane :match_all do |options|
        match_dev(scheme: options[:scheme])
        match_adhoc(scheme: options[:scheme])
        match_release(scheme: options[:scheme])
    end

    desc "Match development certificates for scheme."
    desc "Options: scheme"
    lane :match_dev do |options|
        match_scheme(
            type: "development",
            scheme: options[:scheme]
        )
    end

    desc "Match adhoc certificates for scheme."
    desc "Options: scheme"
    lane :match_adhoc do |options|
        match_scheme(
            type: "adhoc",
            scheme: options[:scheme]
        )
    end

    desc "Match appstore certificates for scheme."
    desc "Options: scheme"
    lane :match_release do |options|
        match_scheme(
            type: "appstore",
            scheme: options[:scheme]
        )
    end

    desc "Increment build number in project"
    lane :increment_build do
        increment_build_number
    end

    desc "Set version."
    desc "Options: version"
    lane :set_version do |options|
        version = options[:version]
        increment_version_number(version_number: version)
    end

    desc "Increment minor version"
    lane :increment_minor_version do
        increment_version_number(bump_type: "minor")
    end

    desc "Download all dSYM files from App Store and upload to the Crashlytics."
    desc "Options: scheme, version and build"
    lane :refresh_dsyms do |options|
        scheme = options[:scheme]
        app_identifier = app_identifiers[scheme][0]

        params = [
            "app_identifier": app_identifier
        ]

        if options.key?("version")
            version = options[:version]
            params["version"] = options[:version]

            if version != "latest" && options.key?("build")
                params["build"] = options[:build]
            end
        end

        download_dsyms(params)
        upload_symbols_to_crashlytics
        clean_build_artifacts
    end

    desc "Download dDSYMs for latest version."
    desc "Options: scheme"
    lane :refresh_dsyms_for_latest_version do |options|
        refresh_dsyms(
            scheme: options[:scheme],
            version: "latest"
        )
    end

    desc "Deploy a new version to the App Store."
    desc "Options: scheme"
    lane :release do |options|
        scheme = options[:scheme]
        app_identifier = app_identifiers[scheme][0]
        metapath = "#{project_metapath}/#{scheme}"
        screenpath = "#{project_screenpath}/#{scheme}"

        clear_derived_data
        cocoapods(repo_update: true)

        unlock_keychain

        match_release(scheme: scheme)

        # Disable automatic code signing -> build -> enable again
        set_manual_code_signing(
            provisioning_profile_mapping: lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING],
            scheme: scheme
        )
        begin
            gym(
                scheme: "#{scheme}",
                clean: true,
                output_directory: "artefacts",
                output_name: "#{scheme}.ipa",
                include_bitcode: true,
                skip_profile_detection: true,
                export_method: "app-store",
                export_options: {
                    # use only provisioning profiles from match
                    provisioningProfiles: lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING]
                }
            )
        ensure
            set_auto_code_signing(
                provisioning_profile_mapping: lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING],
                scheme: scheme
            )
            clean_build_artifacts
        end

        deliver(
            force: true,
            metadata_path: metapath,
            screenshots_path: screenpath,
            app_identifier: app_identifier,
            username: deliver_username
        )

        slack(
            message: "Successfully released iOS RELEASE #{scheme} #{version_string(get_version_number, get_build_number)}",
            channel: "#ios-ci"
        )
    end

    error do |lane, exception|
        slack(
            message: exception.message,
            success: false
        )
    end
end
